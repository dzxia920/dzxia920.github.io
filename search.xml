<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Github Page和域名解绑</title>
    <url>/2023/09/06/Github%20Page%E5%92%8C%E5%9F%9F%E5%90%8D%E8%A7%A3%E7%BB%91/</url>
    <content><![CDATA[<p>问题描述：当域名过期后，通过username.github.io访问Github Pages会自动跳转到原过期域名，从而无法访问</p>
<p>个人解决方法：此时需要实现Github Pages和域名解绑，解绑方式许多博客已经说过，核心就是要删除CNAME，然而，使用这种方法还是会跳转，后面发现是因为配置了Hexo，需要删除掉hexo目录下的<code>source\CNAME</code>文件后再提交，才能删除掉CNAME。接下来再清楚浏览器缓存应该就可以正常访问github Page了</p>
]]></content>
      <categories>
        <category>工作学习</category>
        <category>博客写作</category>
      </categories>
  </entry>
  <entry>
    <title>INS-Probe配合Ublox小天线的工作流</title>
    <url>/2023/05/09/INS-Probe%E9%85%8D%E5%90%88Ublox%E5%B0%8F%E5%A4%A9%E7%BA%BF%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%B5%81/</url>
    <content><![CDATA[<p>这篇博客介绍了使用InsProbe配合Ublox小天线，获取RTK参考值的工作流程</p>
<span id="more"></span>

<h4 id="1-获取基站观测值文件和导航电文"><a href="#1-获取基站观测值文件和导航电文" class="headerlink" title="1. 获取基站观测值文件和导航电文"></a>1. 获取基站观测值文件和导航电文</h4><h5 id="获取基站原始数据"><a href="#获取基站原始数据" class="headerlink" title="获取基站原始数据"></a>获取基站原始数据</h5><p>基站是17F硬件实验室的Panda接收机，其坐标如下：</p>
<table>
<thead>
<tr>
<th></th>
<th>30.5297649350</th>
<th>114.3503808494</th>
<th>100.1529</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>30, 31, 47.153766</td>
<td>114, 21, 1.371058</td>
<td>100.1529</td>
</tr>
</tbody></table>
<p>可根据IP进入Panda接收机内部存储，然后拷贝日期的原始观测数据(dat格式)</p>
<h5 id="原始数据解码"><a href="#原始数据解码" class="headerlink" title="原始数据解码"></a>原始数据解码</h5><p>原始数据可用NovAtel Convert工具进行解码，注意选择<strong>rinex3.02</strong>版本，星座一般只需要GPS+Galileo+BDS</p>
<p>这样就解码得到了基站的O文件和N文件</p>
<p><img src="/./images/insprobe-ublox%E5%B7%A5%E4%BD%9C%E6%B5%81-%E5%9F%BA%E7%AB%99%E5%8E%9F%E5%A7%8B%E6%95%B0%E6%8D%AE%E8%A7%A3%E7%A0%81.png"></p>
<h4 id="2-获取流动站观测值文件"><a href="#2-获取流动站观测值文件" class="headerlink" title="2. 获取流动站观测值文件"></a>2. 获取流动站观测值文件</h4><p>流动站，也就是InsProbe得到的gnss文件后缀是.gnss，是UBlox的特定格式，可用rtklib（2.4.3以上版本）中的RTKCONV工具解码：</p>
<p><img src="/./image/insprobe-ublox-%E6%B5%81%E5%8A%A8%E7%AB%99%E8%A7%A3%E7%A0%81.png"></p>
<h4 id="3-计算RTK结果"><a href="#3-计算RTK结果" class="headerlink" title="3. 计算RTK结果"></a>3. 计算RTK结果</h4><p><strong>注意：</strong>RTKLIB对北斗的支持不好，<strong>需要用一直在更新的RTKLIB_explorer来算</strong></p>
<p>配置策略：</p>
<ul>
<li>小天线是GPS+BDS双系统，在用北斗时可尝试剔除GEO卫星</li>
<li>一般用双频解算，可提前看下流动站观测值的信号质量，如双频大致占比等</li>
<li>后缀F是北斗的星历，后缀N是GPS的星历</li>
<li>基站观测值若太长了，可以手动截取需要的一部分</li>
</ul>
<p><img src="/./image/rtklib_explorer.png"></p>
<p>星历后缀：</p>
<p>n gps </p>
<p>g glonass </p>
<p>q qzss </p>
<p>h GEO</p>
<p>L galileo</p>
<p>F BDS</p>
<p>p是综合的</p>
]]></content>
      <categories>
        <category>工作学习</category>
        <category>专业</category>
      </categories>
      <tags>
        <tag>专业</tag>
      </tags>
  </entry>
  <entry>
    <title>Java核心技术卷1-Chap2-Java程序设计环境</title>
    <url>/2022/06/14/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8D%B71-Chap2-Java%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[<p>本文是Java核心技术卷1-第二章-Java程序设计环境的读书笔记。</p>
<span id="more"></span>

<h2 id="2-1-安装Java开发工具包"><a href="#2-1-安装Java开发工具包" class="headerlink" title="2.1 安装Java开发工具包"></a>2.1 安装Java开发工具包</h2><p>首先有必要弄清下列专业术语：</p>
<table>
<thead>
<tr>
<th align="center">缩写</th>
<th align="center">术语</th>
<th align="center">解释</th>
</tr>
</thead>
<tbody><tr>
<td align="center">JDK</td>
<td align="center">Java Development Kit（Java开发工具包）</td>
<td align="center">编写Java程序所需的软件</td>
</tr>
<tr>
<td align="center">JRE</td>
<td align="center">Java Runtime Environment（Java 运行时环境）</td>
<td align="center">运行Java程序所需的软件</td>
</tr>
<tr>
<td align="center">JVM</td>
<td align="center">Java Virtual Machine（Java虚拟机）</td>
<td align="center">整个 Java 实现跨平台的最核心的部分</td>
</tr>
<tr>
<td align="center">SE</td>
<td align="center">Standard Edition（标准版）</td>
<td align="center">用于桌面或简单服务器应用的Java平台</td>
</tr>
<tr>
<td align="center">EE</td>
<td align="center">Enterprise Edition（企业版）</td>
<td align="center">用于复杂服务器应用的Java平台</td>
</tr>
<tr>
<td align="center">ME</td>
<td align="center">Micro Edition（微型版）</td>
<td align="center">用于小型设备的Java平台</td>
</tr>
<tr>
<td align="center">OpenJDK</td>
<td align="center">-</td>
<td align="center">JavaSE的一个免费开源实现</td>
</tr>
<tr>
<td align="center">J2</td>
<td align="center">Java2</td>
<td align="center">用于描述1998-2006年之间的Java版本</td>
</tr>
<tr>
<td align="center">SDK</td>
<td align="center">Software Development Kit（软件开发工具包）</td>
<td align="center">用于描述1998-2006年之间的JDK</td>
</tr>
</tbody></table>
<p>Java语言的版本演进是1.0、1.1、1.2、1.3、1.4、5.0、6、7、8、9等。为了反映版本1.2的重大改进，版本1.2—版本1.4被命名为Java2。而且JDK1.2—JDK1.4被称为Java SDK。2006年版本号得到简化，于是标准版就有了Java SE6、Java SE7、JavaSE8.</p>
<p>在Java9之前，JDK有32位和64位两种，但是现在只有64位的。</p>
<p>JavaSE版本与JDK版本的对应关系是：</p>
<p><img src="/images/Java%E7%89%88%E6%9C%AC%E5%92%8CJDK%E7%89%88%E6%9C%AC%E7%9A%84%E5%AF%B9%E5%BA%94%E5%85%B3%E7%B3%BB.png"></p>
<p>参考：<a href="https://blog.csdn.net/MinggeQingchun/article/details/120578602">https://blog.csdn.net/MinggeQingchun/article/details/120578602</a></p>
<p>安装并配置完JDK后，输入<code>javac --version</code>可检查是否配置正确。这里的<code>javac</code>是Java语言编译器，即<code>Java Compiler</code>.</p>
<p><strong>JDK、JRE、JVM的关系是：</strong></p>
<p>JDK(Java Development Kit) 是整个JAVA的核心，包括了Java运行环境（Java Runtime Envirnment），一堆Java工具（javac&#x2F;java&#x2F;jdb等）和Java基础的类库（即Java API 包括rt.jar）。<br>JDK是java开发工具包，基本上每个学java的人都会先在机器 上装一个JDK，那他都包含哪几部分呢？在目录下面有 六个文件夹、一个src类库源码压缩包、和其他几个声明文件。其中，真正在运行java时起作用的 是以下四个文件夹：bin、include、lib、 jre。有这样一个关系，JDK包含JRE，而JRE包 含JVM。<br>这篇博客讲的很清楚：<a href="https://blog.csdn.net/ancientear/article/details/79483592">https://blog.csdn.net/ancientear/article/details/79483592</a></p>
<p><img src="/images/jdk-jre-jvm%E5%85%B3%E7%B3%BB.jpg"></p>
<h2 id="2-2-使用命令行工具"><a href="#2-2-使用命令行工具" class="headerlink" title="2.2 使用命令行工具"></a>2.2 使用命令行工具</h2><p>使用文本编辑器编写一个后缀为.java的文件，然后键入如下命令：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">javac Welcome.java</span><br><span class="line">java Welcome</span><br></pre></td></tr></table></figure>

<p>第一条命令会调用<strong>Java编译器</strong>生成对应的字节码（.class文件），需要指定文件名；</p>
<p>第二条命令会<strong>运行程序</strong>，只需要指定类名。</p>
<h2 id="2-3-使用集成开发环境"><a href="#2-3-使用集成开发环境" class="headerlink" title="2.3 使用集成开发环境"></a>2.3 使用集成开发环境</h2><p>书上用的是Eclipse，目前自己用的是IDEA的Educational Edition</p>
<h2 id="2-4-JShell"><a href="#2-4-JShell" class="headerlink" title="2.4 JShell"></a>2.4 JShell</h2><p>可能自己的JDK用的是Android时装的那份（OpenJDK11），JShell打开不了。</p>
<p><strong>小结：</strong>感觉这一节主要是熟悉Java中的一些术语，如JDK、JRE、Java SE，了解各个版本的对应关系。以及配置JDK，使用命令行工具。</p>
]]></content>
      <categories>
        <category>工作学习</category>
        <category>编程</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>Coding</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java核心技术卷1-Chap1-Java程序设计概述</title>
    <url>/2022/06/12/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8D%B71-Chap1-Java%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<p>本文是Java核心技术卷1-第一章-Java程序设计概述的读书笔记。</p>
<span id="more"></span>

<h2 id="1-1-Java程序设计平台"><a href="#1-1-Java程序设计平台" class="headerlink" title="1.1 Java程序设计平台"></a>1.1 Java程序设计平台</h2><p>Java是功能齐全的出色语言，是一个高质量的执行环境，还提供了一个庞大的库。因此Java是一个完整的平台。</p>
<h2 id="1-2-Java“白皮书”关键术语"><a href="#1-2-Java“白皮书”关键术语" class="headerlink" title="1.2 Java“白皮书”关键术语"></a>1.2 Java“白皮书”关键术语</h2><ol>
<li><strong>简单性</strong>。Java语法是C++语法的纯净版本，没有头文件、指针运算、结构、联合、操作符重载、虚基类等。设计Java时使其尽可能接近C++，但是剔除了许多很少使用、难以理解、容易混淆的特性。</li>
<li><strong>面向对象</strong>。多重继承Java中采取的是更简单的接口。此外，提供了更丰富的运行时自省功能。</li>
<li><strong>分布式</strong>。Java有一个丰富的例程库，用于处理像HTTP和FTP之类的TCP&#x2F;IP协议。</li>
<li><strong>健壮性</strong>。Java采用的指针模型可以消除重写内存和损坏数据的可能性。</li>
<li><strong>安全性</strong>。Java可以构建防病毒、防篡改的系统。</li>
<li><strong>体系结构中立</strong>。编译器会生成一个目标文件格式，此格式与平台无关，只要有Java运行时系统就可以解释执行，此字节码还可以转成本地机器代码。</li>
<li><strong>可移植性</strong>。Java基本数据类型的大小和有关运算的行为都有明确的说明，比如int永远是32位。在Java中，数值类型有固定的字节数，二进制数据以固定的格式进行存储和传输（消除了字节顺序的困扰），字符串则采用标准的Unicode格式存储。</li>
<li><strong>解释型</strong>。Java解释器可以在任何移植了解释器的机器上执行Java字节码。</li>
<li><strong>高性能</strong>。解释后的字节码性能还不错。即时编译器也会优化代码。</li>
<li><strong>多线程</strong>。Java可以很好的管理并发程序设计。</li>
<li><strong>动态性</strong>。动态语言？不太理解。</li>
</ol>
<h2 id="1-3-Java-applet与Internet"><a href="#1-3-Java-applet与Internet" class="headerlink" title="1.3 Java applet与Internet"></a>1.3 Java applet与Internet</h2><p>Java applet的想法是：用户从Internet上下载Java字节码，并在自己的机器上运行。在网页中运行的Java程序称为applet。要使用applet，只需要一个启动了Java的web浏览器，它来执行字节码，不需要安装任何软件。但是这种想法因为版本不同、浏览器限制、安全问题等泡汤了。</p>
<h2 id="1-4-发展简史"><a href="#1-4-发展简史" class="headerlink" title="1.4 发展简史"></a>1.4 发展简史</h2><p>创始人是Sun公司的<strong>Patrick Naughton</strong>和<strong>James Gosling</strong>。</p>
<p>Java语言的演进：</p>
<p>目前用的最多的是Java8，2017年发布了Java9.</p>
<p>参考这篇文章</p>
<p><a href="https://www.jinxuliang.com/course/Java/5_JavaHistory/PPT.pdf">https://www.jinxuliang.com/course/Java/5_JavaHistory/PPT.pdf</a></p>
<h2 id="1-5-关于Java常见的误解和解释"><a href="#1-5-关于Java常见的误解和解释" class="headerlink" title="1.5 关于Java常见的误解和解释"></a>1.5 关于Java常见的误解和解释</h2><p>误解：Java是解释型型的，因此对于关键的应用程序速度太慢了。</p>
<p>解释：早期Java是解释型的，现在Java虚拟机使用了即时编译器。因此采用Java编写的<strong>热点代码</strong>（对于程序来说，通常只有一部分代码会被经常执行，而应用的性能主要取决于这些代码执行得有多快。这些关键代码段被称为应用的热点代码）速度和C++相差无几，甚至更快。</p>
]]></content>
      <categories>
        <category>工作学习</category>
        <category>编程</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>Coding</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java核心技术卷1-Chap3-Java程序设计基本结构</title>
    <url>/2022/06/12/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8D%B71-Chap3-Java%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<p>本文是Java核心技术卷1-第3章-Java程序设计基本结构的读书笔记。</p>
<span id="more"></span>

<h2 id="3-1-一个简单的Java应用程序"><a href="#3-1-一个简单的Java应用程序" class="headerlink" title="3.1 一个简单的Java应用程序"></a>3.1 一个简单的Java应用程序</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FirstSample</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;We will not use &#x27;Hello World&#x27;!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是一段最简单的Java程序，有一些值得注意的地方：</p>
<ul>
<li>Java区分大小写</li>
<li>Java程序的所有内容都要包含在<code>class</code>中</li>
<li>关键字<code>class</code>后紧跟着类名，标准的类名命名规范为<strong>驼峰命名法</strong></li>
<li><strong>源代码的文件名</strong>必须与<strong>公共类的类名</strong>相同（需<strong>完全一致</strong>，case-sensitive），并使用<code>.java</code>作为拓展名</li>
<li>运行已编译的程序时，Java虚拟机总是<strong>从指定类中的main方法处开始执行</strong>。因此类的源文件中必须包含一个main方法</li>
<li>Java中的main方法必须是静态<code>static</code>的</li>
</ul>
<p><strong>注意：</strong>根据Java语规范，main方法必须声明成public。</p>
<h2 id="3-2-注释"><a href="#3-2-注释" class="headerlink" title="3.2 注释"></a>3.2 注释</h2><p>Java中的注释有三种：</p>
<ul>
<li>使用<code>//</code>，注释范围到行尾；</li>
<li>使用<code>/*</code>和<code>*/</code>来界定注释；</li>
<li>以<code>/**</code>开始，以<code>*/</code>结束，这种注释方法可用来自动生成文档。</li>
</ul>
<p><strong>警告：</strong>Java中<code>/*</code>和<code>*/</code>不能嵌套，也就是说不能直接将代码用<code>/*</code>和<code>*/</code>括起来注释，因为中间可能还会碰到<code>*/</code>界定符。</p>
<h2 id="3-3-数据类型"><a href="#3-3-数据类型" class="headerlink" title="3.3 数据类型"></a>3.3 数据类型</h2><p>Java是一种<em><strong>强类型语言</strong></em>。因此必须为每一种变量声明一种类型。<strong>在Java中一共有8种基本类型(primitive type)：4种整形、2种浮点型、1种字符型<code>char</code>、1种布尔类型<code>boolean</code>。</strong></p>
<p><strong>注意：</strong>Java种还有一种能表示任意精度的算术包，通常称为“<strong>大数”</strong>，但它不是一种Java基本类型，而是一个Java对象。</p>
<h3 id="3-3-1-整型"><a href="#3-3-1-整型" class="headerlink" title="3.3.1 整型"></a>3.3.1 整型</h3><p>Java种的整型有：<code>int</code>、<code>short</code>、<code>long</code>、<code>byte</code>，均允许有负数。注意：Java种没有任何无符号形式的<code>int</code>、<code>short</code>、<code>long</code>、<code>byte</code>类型。</p>
<p><img src="/images/java/Java-%E6%95%B4%E5%9E%8B.jpg"></p>
<p>Java种整型的范围和所占存储空间与平台无关，因此能保证在任何机器上都得到相同的运行结果。</p>
<p>整型数值的表示：</p>
<ul>
<li>长整型数值后有一个后缀<code>L</code>或者<code>l</code>，如<code>40000000000L</code></li>
<li>十六进制数值后有一个前缀<code>0x</code>或者<code>0X</code></li>
<li>八进制数值前有一个<code>0</code></li>
<li>从Java7开始，加上<code>0b</code>或者<code>0B</code>前缀就可以写二进制数，如<code>0b1001</code>就是<code>9</code>，数字字面量可以<strong>加下划线</strong>让人更易读，编译器实际上会去掉这些下划线，如<code>1_000_000</code></li>
</ul>
<h3 id="3-3-2-浮点类型"><a href="#3-3-2-浮点类型" class="headerlink" title="3.3.2 浮点类型"></a>3.3.2 浮点类型</h3><p>Java种的浮点类型有<code>float</code>和<code>double</code>，<code>float</code>有效位数是6<del>7位，<code>double</code>有效位数是15</del>16位。</p>
<p><img src="/images/java/Java-%E6%B5%AE%E7%82%B9%E5%9E%8B.jpg"></p>
<p>浮点类型的表示：</p>
<ul>
<li><code>float</code>类型后有一个后缀<code>F</code>或<code>f</code>（例如<code>3.14F</code>）</li>
<li>没有后缀的浮点数值默认为<code>double</code>，当然，也可以在后面添加<code>D</code>或<code>d</code>后缀。</li>
</ul>
<p><strong>注释：</strong>还可以用十六进制表示浮点数值，例如<code>0.125=2^-3</code>可以表示成<code>0x1.0p-3</code>，十六进制表示法种<code>p</code>表示指数而不是<code>e</code>，尾数采用十六进制，而指数采用十进制，而且指数的基数是<code>2</code>而不是<code>10</code>。</p>
<p>所有的浮点数值计算都遵循IEEE 754规范。下面是用于表示溢出或出错情况的三个特殊的浮点数值：</p>
<ul>
<li><code>Double.POSITIVE_INFINITY</code>，正无穷大</li>
<li><code>Double.NEGATIVE_INFINITY</code>，负无穷大</li>
<li><code>Double.NaN</code>，不是一个数字</li>
</ul>
<p><strong>注意：</strong>所有的“非数值”的值都认为是不同的，不能直接比较(如<code>x==Double.NaN</code>)，但可以使用内置的方法来比较（<code>Double.isNaN(x)</code>）。</p>
<h3 id="3-3-3-char类型"><a href="#3-3-3-char类型" class="headerlink" title="3.3.3 char类型"></a>3.3.3 char类型</h3><p>char类型原本用于表示单个字符，但如今有些Unicode字符也可以用一个char值来描述，另外一些Unicode字符则需要两个字符。</p>
<p>char类型的字面值常量需要用<strong>单引号</strong>括起来。char类型的值可以表示为十六进制值，范围从<code>\u0000</code>到<code>\uFFFF</code>，</p>
<h3 id="3-3-4-Unicode与char类型"><a href="#3-3-4-Unicode与char类型" class="headerlink" title="3.3.4 Unicode与char类型"></a>3.3.4 Unicode与char类型</h3><h3 id="3-3-5-boolean类型"><a href="#3-3-5-boolean类型" class="headerlink" title="3.3.5 boolean类型"></a>3.3.5 boolean类型</h3><p>boolean类型有两个值：<code>false</code>和<code>true</code>，注意：<strong>Java中整数值和布尔值之间不能进行相互转换</strong>。</p>
<h2 id="3-4-变量与常量"><a href="#3-4-变量与常量" class="headerlink" title="3.4 变量与常量"></a>3.4 变量与常量</h2><h3 id="3-4-1-声明变量"><a href="#3-4-1-声明变量" class="headerlink" title="3.4.1 声明变量"></a>3.4.1 声明变量</h3><p>Java中每个变量都有一个类型，在声明变量时，首先指定变量的类型，然后再指定变量名：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span> salary;</span><br><span class="line"><span class="type">boolean</span> done;</span><br></pre></td></tr></table></figure>

<p>变量<strong>命名的规则</strong>：…</p>
<p>可以在一行中声明多个变量，但不建议这样做，逐一声明可以提高程序的可读性。</p>
<h3 id="3-4-2-变量初始化"><a href="#3-4-2-变量初始化" class="headerlink" title="3.4.2 变量初始化"></a>3.4.2 变量初始化</h3><p><strong>声明一个变量后必须用赋值语句对变量进行显示初始化。</strong>不能够使用未初始化的变量的值。Java不区分变量的声明和定义。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> vacationDays;</span><br><span class="line">vacationDays = <span class="number">12</span>;</span><br><span class="line"><span class="comment">// or</span></span><br><span class="line"><span class="type">int</span> <span class="variable">vacationDays</span> <span class="operator">=</span> <span class="number">12</span>;</span><br></pre></td></tr></table></figure>

<p>在Java程序编写风格中，变量的声明应接近第一次使用的地方。</p>
<p>从Java10开始，对于局部变量，如果可以从变量的初始值推导它的类型，就可以使用关键字<code>var</code>而不指定声明类型：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">var</span> <span class="variable">greeting</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>; <span class="comment">// greeting is a String</span></span><br></pre></td></tr></table></figure>

<h3 id="3-4-3-常量"><a href="#3-4-3-常量" class="headerlink" title="3.4.3 常量"></a>3.4.3 常量</h3><p>Java中使用关键字<code>final</code>来表示常量。习惯上，常量名采用全大写。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">double</span> <span class="variable">CM_PER_INCH</span> <span class="operator">=</span> <span class="number">2.54</span>;</span><br></pre></td></tr></table></figure>

<h3 id="3-4-4-枚举类型"><a href="#3-4-4-枚举类型" class="headerlink" title="3.4.4 枚举类型"></a>3.4.4 枚举类型</h3><p>有时变量的值只会是在某一取值集合内，比如衣服的尺寸有S、M、L、X。如果想让变量只在这个集合内取值，而不能保存其他错误的值，可以自定义<strong>枚举类型</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Size</span> &#123;SMALL, MEDIUM, LARGE, EXTRA_LARGE&#125;;</span><br><span class="line"><span class="type">Size</span> <span class="variable">s</span> <span class="operator">=</span> Size.MEDIUM;</span><br></pre></td></tr></table></figure>

<p>Size类型的变量存储的值只能是声明中给定的<code>某个枚举值</code>，或者特殊值<code>null</code>，<code>null</code>表示这个变量没有设置任何值。</p>
<h2 id="3-5-运算符"><a href="#3-5-运算符" class="headerlink" title="3.5 运算符"></a>3.5 运算符</h2><h3 id="3-5-1-算数运算符"><a href="#3-5-1-算数运算符" class="headerlink" title="3.5.1 算数运算符"></a>3.5.1 算数运算符</h3><p>算数运算符有<code>+</code>、<code>-</code>、<code>*</code>、<code>/</code>、<code>%</code>，分别表示加、减、乘、除、取余(求模)。</p>
<p><strong>注意：</strong>浮点数运算的可移植性实现起来很难，例如：double类型使用64位存储一个数值，而有些处理器使用80位的浮点寄存器，这些寄存器增加了中间过程的计算精度，而且避免了指数溢出，但这个结果可能与64位计算的结果<strong>不一样</strong>。如果要使用严格的浮点计算来生成<strong>可再生的结果</strong>，可以把方法或类标记成<code>strictfp</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">strictfp</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br></pre></td></tr></table></figure>

<h3 id="3-5-2-数学函数与常量"><a href="#3-5-2-数学函数与常量" class="headerlink" title="3.5.2 数学函数与常量"></a>3.5.2 数学函数与常量</h3><p>在<code>Math</code>类中包含各种各样的数学函数。</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>操作</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>Math.sqrt(x)</td>
<td>计算x的平方根</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Math.pow(x, a)</td>
<td>计算x的a次幂</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Math.floorMod(x)</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h3 id="3-5-3-数值类型之间的转换"><a href="#3-5-3-数值类型之间的转换" class="headerlink" title="3.5.3 数值类型之间的转换"></a>3.5.3 数值类型之间的转换</h3><h3 id="3-5-4-强制类型转换"><a href="#3-5-4-强制类型转换" class="headerlink" title="3.5.4 强制类型转换"></a>3.5.4 强制类型转换</h3><h3 id="3-5-5-结合赋值和运算符"><a href="#3-5-5-结合赋值和运算符" class="headerlink" title="3.5.5 结合赋值和运算符"></a>3.5.5 结合赋值和运算符</h3><h3 id="3-5-6-自增和自减运算符"><a href="#3-5-6-自增和自减运算符" class="headerlink" title="3.5.6 自增和自减运算符"></a>3.5.6 自增和自减运算符</h3><h3 id="3-5-7-关系和boolean运算符"><a href="#3-5-7-关系和boolean运算符" class="headerlink" title="3.5.7 关系和boolean运算符"></a>3.5.7 关系和boolean运算符</h3><h3 id="3-5-8-位运算符"><a href="#3-5-8-位运算符" class="headerlink" title="3.5.8 位运算符"></a>3.5.8 位运算符</h3><h3 id="3-5-9-括号和运算符级别"><a href="#3-5-9-括号和运算符级别" class="headerlink" title="3.5.9 括号和运算符级别"></a>3.5.9 括号和运算符级别</h3><h2 id="3-6-字符串"><a href="#3-6-字符串" class="headerlink" title="3.6 字符串"></a>3.6 字符串</h2><h2 id="3-8-控制流程"><a href="#3-8-控制流程" class="headerlink" title="3.8 控制流程"></a>3.8 控制流程</h2><p>Java中使用条件语句、循环结构来确定控制流程。</p>
<h3 id="3-8-1-块作用域"><a href="#3-8-1-块作用域" class="headerlink" title="3.8.1 块作用域"></a>3.8.1 块作用域</h3><p>块（即复合语句）是指由若干条Java语句组成的语句，并用一对大括号括起来。块确定了变量的作用域，块可以嵌套。</p>
<p><strong>注意：</strong>不能在嵌套块中声明同名的变量。（但在C++中可以，内层同名变量隐藏外层变量）</p>
<h3 id="3-8-2-条件语句"><a href="#3-8-2-条件语句" class="headerlink" title="3.8.2 条件语句"></a>3.8.2 条件语句</h3><p>Java中条件语句的格式为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (condition) statement1 <span class="keyword">else</span> statement2</span><br></pre></td></tr></table></figure>

<p>statement常采用块（复合语句）。</p>
<h3 id="3-8-3-循环语句"><a href="#3-8-3-循环语句" class="headerlink" title="3.8.3 循环语句"></a>3.8.3 循环语句</h3><p>当条件为true时，<strong>while循环</strong>执行：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (condition) statement</span><br></pre></td></tr></table></figure>

<p>在上面的这种while语句中，statement可能一次都不执行。为了保证statement至少执行一次，可以使用**<code>do/while</code>循环**。语法如下：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span> statement <span class="keyword">while</span> (condition)</span><br></pre></td></tr></table></figure>

<p><strong><code>for</code>循环</strong>是支持迭代的一种通用结构，由一个计数器或者类似的变量控制迭代次数，每次迭代后计数器更新。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++)</span><br><span class="line">    statement;</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong>检测浮点数是否相等时需要额外注意，因为会有舍入误差。</p>
<p>多重选择：**<code>switch</code>语句**，Java中的<code>switch</code>语句和C++中的完全一样。其语法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> (choice)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>case</code>标签可以是：</p>
<ul>
<li>类型为<code>char</code>、<code>byte</code>、<code>short</code>或<code>int</code>的常量表达式</li>
<li>枚举常量</li>
<li>从Java7开始，<code>case</code>标签还可以是字符串字面量</li>
</ul>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">input</span> <span class="operator">=</span> ...;</span><br><span class="line"><span class="keyword">switch</span> (input.toLowerCase())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;yes&quot;</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>中断控制流程有**<code>break</code>语句<strong>和</strong><code>Continue</code>语句**。Java中提供了两种<code>break</code>语句，一种与C++中的一致，另一种是带标签的<code>break</code>语句。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">label:</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (condition) <span class="keyword">break</span> label;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong>标签必须放在希望跳出的最外层循环之前，且必须紧跟一个冒号。</p>
<p>同样的，continue语句也有带标签和不带标签两种形式。</p>
<h2 id="3-9-大数"><a href="#3-9-大数" class="headerlink" title="3.9 大数"></a>3.9 大数</h2><p><code>java.math</code>包中有两个很有用的类：<code>BigInteger</code>和<code>BigDecimal</code>。这两个类可以处理包含任意长度字符序列的数值。<code>BigInteger</code>用于实现任意精度的整数运算，<code>BigDecimal</code>用于实现任意精度的浮点数运算。例如在金融货币方面就非常有必要。</p>
<p>使用静态的<code>valueOf</code>方法可以将普通的数值转换为大数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">BigInteger</span> <span class="variable">a</span> <span class="operator">=</span> BigInteger.valueOf(<span class="number">100</span>);</span><br></pre></td></tr></table></figure>

<p>对于更大的数，可以采用一个带字符串的参数构造器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">BigInteger</span> <span class="variable">reallyBig</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigInteger</span>(<span class="string">&quot;22222222342342347238563278562374526312847198547825&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>另外大数类中也定义了一些常量：<code>BigInteger.ZERO</code>、<code>BigInteger.TEN</code>、<code>BigInteger.ONE</code>、<code>BigInteger.TWO</code>。</p>
<p><strong>注意：</strong>不能用常用的算术运算符处理大数，而需要使用大数类中的<code>add</code>和<code>multiply</code>方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">BigInteger</span> <span class="variable">c</span> <span class="operator">=</span> a.add(b); <span class="comment">// c = a + b</span></span><br><span class="line"><span class="type">BigInteger</span> <span class="variable">d</span> <span class="operator">=</span> c.multiply(b.add(BigInteger.valueOf(<span class="number">2</span>))) <span class="comment">// d = c * (b + 2)</span></span><br></pre></td></tr></table></figure>

<p>更多的大数操作可以见：<a href="http://c.biancheng.net/view/871.html">http://c.biancheng.net/view/871.html</a></p>
<h2 id="3-10-数组"><a href="#3-10-数组" class="headerlink" title="3.10 数组"></a>3.10 数组</h2><p>Java中的数组声明如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[] a; <span class="comment">// 数组的声明</span></span><br><span class="line"><span class="type">int</span>[] a = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">100</span>]; <span class="comment">// 声明并初始化可存储100个整数的数组</span></span><br><span class="line"><span class="type">var</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">100</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">    System.out.println(a[i]);</span><br><span class="line">    a[i] = i;</span><br><span class="line">    System.out.println(a[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Java中的</p>
]]></content>
      <categories>
        <category>工作学习</category>
        <category>编程</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>Coding</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Latex学习记录</title>
    <url>/2023/01/20/Latex%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<!--more 本文介绍了学习Latex的记录。-->

<h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><p>要使用LaTex，首先需要准备好必备的软件环境。即，我们要在电脑上安装一个 TEX 发行版。现在比较常用的Tex发行版有：</p>
<ul>
<li>Tex Live：适用于Windows和Linux，安装体积大</li>
<li>MacTeX：仅适用于Mac</li>
<li>MikTeX：适用于所有平台，安装体积小</li>
</ul>
<p>所谓 TeX 发行，也叫 TeX 发行版、TeX 系统或者 TeX 套装，指的是包括 TeX 系统的各种可执行程序，以及他们执行时需要的一些辅助程序和宏包文档的集合。</p>
<p>TeX 的源代码是后缀为 <code>.tex</code> 的纯文本文件。为了便于编辑，我们可以安装一款编辑器。TeXworks是一款专用于编辑TeX的编辑器，在安装TeX Live或MikTeX发行版时，会自带TeXworks编辑器。这里推荐安装TeX Live。</p>
<h2 id="TeXworks简单使用"><a href="#TeXworks简单使用" class="headerlink" title="TeXworks简单使用"></a>TeXworks简单使用</h2><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="https://zhuanlan.zhihu.com/p/571658538">https://zhuanlan.zhihu.com/p/571658538</a> LaTeX 快速指南（一）：安装 TeX 发行版</li>
<li><a href="https://liam.page/texlive/">https://liam.page/texlive/</a> TeX Live 下载及安装说明</li>
<li><a href="https://liam.page/2014/09/08/latex-introduction/">https://liam.page/2014/09/08/latex-introduction/</a> 一份其实很短的 LaTeX 入门文档</li>
</ol>
]]></content>
      <categories>
        <category>工作学习</category>
        <category>博客写作</category>
      </categories>
      <tags>
        <tag>Latex</tag>
      </tags>
  </entry>
  <entry>
    <title>MATLAB绘图窗口最大化</title>
    <url>/2022/06/07/MATLAB%E7%BB%98%E5%9B%BE%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%8C%96/</url>
    <content><![CDATA[<p>MATLAB中figure窗口一般都是以默认大小显示的，若要将其最大化显示，可以这样做：</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">set(gcf, <span class="string">&quot;Position&quot;</span>, get(<span class="number">0</span>,<span class="string">&#x27;ScreenSize&#x27;</span>))</span><br></pre></td></tr></table></figure>
<span id="more"></span>

<p>此时保存的图像也是放大后的。如：</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">saveas(gcf, <span class="string">&#x27;TrajPics.tiff&#x27;</span>);</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>工作学习</category>
        <category>编程</category>
        <category>MATLAB</category>
      </categories>
      <tags>
        <tag>MATLAB</tag>
        <tag>小技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>Git-Message个人规范</title>
    <url>/2023/09/12/Git-Message%E4%B8%AA%E4%BA%BA%E8%A7%84%E8%8C%83/</url>
    <content><![CDATA[<p>本文介绍了在Git Commit时message的个人使用规范</p>
<span id="more"></span>

<hr>
<p>结合阿里开发者的博客，给出了个人<code>Git Commit Message</code>的规范如下：</p>
<p><code>git commit -m&quot;&lt;type&gt;: message&quot;</code></p>
<p>其中，<code>type</code>分为以下几种类型：</p>
<ul>
<li><code>init</code>，初始化</li>
<li><code>feat</code>，新特性</li>
<li><code>refactor</code>，重构</li>
<li><code>style</code>，风格改变</li>
<li><code>docs</code>，文档</li>
<li><code>perf</code>，性能优化</li>
<li><code>test</code>，测试</li>
<li><code>fix</code>，修复bug</li>
</ul>
<blockquote><footer><strong>阿里开发者，知乎</strong><cite><a href="https://zhuanlan.zhihu.com/p/182553920">如何规范你的Git commit？</a></cite></footer></blockquote>]]></content>
      <categories>
        <category>工作学习</category>
        <category>编程</category>
        <category>Git</category>
      </categories>
  </entry>
  <entry>
    <title>MATLAB计算矩阵每一行的范数</title>
    <url>/2023/09/11/MATLAB%E8%AE%A1%E7%AE%97%E7%9F%A9%E9%98%B5%E6%AF%8F%E4%B8%80%E8%A1%8C%E7%9A%84%E8%8C%83%E6%95%B0/</url>
    <content><![CDATA[<p><code>A</code>是矩阵，<code>vecnorm(A,p,2)</code> 计算每一行的范数，</p>
<ul>
<li>若计算每一行的二范数，即<code>vecnorm(A,2,2)</code></li>
<li>若计算每一列的二范数，即<code>vecnorm(A,2,1)</code></li>
</ul>
]]></content>
      <tags>
        <tag>MATLAB</tag>
        <tag>工作学习</tag>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title>ftp下载IGS广播星历</title>
    <url>/2023/05/11/ftp%E4%B8%8B%E8%BD%BDIGS%E5%B9%BF%E6%92%AD%E6%98%9F%E5%8E%86/</url>
    <content><![CDATA[<p>这篇文章介绍了如何用ftp方式下载igs多系统广播星历。</p>
<span id="more"></span>
<h4 id="下载IGS广播星历"><a href="#下载IGS广播星历" class="headerlink" title="下载IGS广播星历"></a>下载IGS广播星历</h4><ol>
<li><code>ftp igs.gnsswhu.cn</code></li>
<li>匿名登录，用户名<code>anonymous</code>，密码随便输</li>
<li>虚拟机下需要输入<code>passive</code>命令</li>
<li>进入<code>\pub\gps\data\daily\</code>目录下，进入对应年份、对应年积日的文件下的<code>23p</code>子目录（年积日可在这里查看：<a href="http://www.igs.gnsswhu.cn/index.php/home/data_product/igs.html%EF%BC%8Cp%E6%84%8F%E5%91%B3%E7%9D%80%E6%98%AF%E5%A4%9A%E7%B3%BB%E7%BB%9F%EF%BC%89">http://www.igs.gnsswhu.cn/index.php/home/data_product/igs.html，p意味着是多系统）</a></li>
<li><code>ls BRDM*</code>找到对应的多系统广播星历文件</li>
<li><code>get [BRDM文件名]</code>下载该广播星历</li>
<li>退出<code>bye</code></li>
<li>最后需要改下后缀为P才能在rtklib下使用</li>
</ol>
]]></content>
      <categories>
        <category>工作学习</category>
        <category>专业</category>
      </categories>
      <tags>
        <tag>教程</tag>
      </tags>
  </entry>
  <entry>
    <title>git个人使用小结</title>
    <url>/2022/08/06/git%E4%B8%AA%E4%BA%BA%E4%BD%BF%E7%94%A8%E5%B0%8F%E7%BB%93/</url>
    <content><![CDATA[<p>这是在使用Git时的一些感触和小结。</p>
<span id="more"></span>

<h2 id="为什么要使用Git"><a href="#为什么要使用Git" class="headerlink" title="为什么要使用Git"></a>为什么要使用Git</h2><p>当你的代码改动时，你不想每次都去做注释，或者说每次要手动复制文件夹备份一下，这样很麻烦。为了能够写出干净的代码，不要的东西就大胆删去，有了Git完全就可以这样做。</p>
<h2 id="总体流程"><a href="#总体流程" class="headerlink" title="总体流程"></a>总体流程</h2><h3 id="初始仓库"><a href="#初始仓库" class="headerlink" title="初始仓库"></a>初始仓库</h3><p>首先需要创建一个仓库。。。。【TODO，下次创建新仓库的时候再写吧】，一种是从0开始创建，另一种是对已有的文件夹添加Git版本控制</p>
<h4 id="从已有文件夹中创建"><a href="#从已有文件夹中创建" class="headerlink" title="从已有文件夹中创建"></a>从已有文件夹中创建</h4><p>切换到该文件夹下，输入<code>$ git init</code>初始化仓库，此时会有默认的<code>master</code>分支</p>
<p><img src="/git%E4%BB%8E%E5%B7%B2%E6%9C%89%E6%96%87%E4%BB%B6%E5%A4%B9%E5%88%9B%E5%BB%BA%E6%96%B0%E4%BB%93%E5%BA%93.png"></p>
<p><code>$ git add .</code>和<code>git commit</code>将当前文件夹下的文件添加到仓库，如果有文件不想添加，提前写好<code>.gitignore</code>文件</p>
<p>这样，本地仓库已经创建好了，如果要添加远程库，首先需要在GitHub上创建一个远程库（不要add readme和许可证），然后通过<code>git remote add origin 远程仓库地址 </code>的方式关联远程库，可以使用<code>$ git remote -v</code>命令查看是否添加了远程库，接下来就可以通过<code>$ git push origin branch-name</code>将本地的分支推送到远程仓库了. 如果需要修改分支名，可以使用<code>$ git branch -M oldname newname</code>。</p>
<h3 id="操作流程"><a href="#操作流程" class="headerlink" title="操作流程"></a>操作流程</h3><p>其实使用的流程很简单。将每一次备份都添加到一个新分支里，这样也不考虑要合并冲突的问题了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">查看分支</span><br><span class="line">$ git branch</span><br><span class="line">创建新分支</span><br><span class="line">$ git branch (branchname)</span><br><span class="line">转到分支</span><br><span class="line">$ git checkout (branchname)</span><br><span class="line">全部添加</span><br><span class="line">$ git add .</span><br><span class="line">提交修改</span><br><span class="line">$ git commit -m&quot;修改说明&quot;</span><br><span class="line">将更改应用到远程仓库,如果远程没有branchname会新建</span><br><span class="line">$ git push origin (branchname)</span><br></pre></td></tr></table></figure>

<h2 id="Git-ignore文件的编写"><a href="#Git-ignore文件的编写" class="headerlink" title="Git ignore文件的编写"></a>Git ignore文件的编写</h2><p>在你的项目文件夹下，除了代码文件，当然还会有各种各样的数据和结果文件，这就导致整个工程会很大，一般来说，原始数据是不会变的，而结果是可以重新生成的，因此在Git上不会备份原始数据和结果。这就需要去编写ignore文件。<br>步骤分为两步：</p>
<ol>
<li><p>找一个对应你项目代码的模板，比如可以搜matlab ignore文件模板</p>
</li>
<li><p>在此基础上，再根据自己的需要选择保存或者不保存什么文件</p>
</li>
</ol>
<p>示例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">##---------------------------------------------------</span><br><span class="line">## Remove autosaves generated by the Matlab editor</span><br><span class="line">## We have git for backups!</span><br><span class="line">##---------------------------------------------------</span><br><span class="line"></span><br><span class="line"># Windows default autosave extension</span><br><span class="line">*.asv</span><br><span class="line"></span><br><span class="line"># OSX / *nix default autosave extension</span><br><span class="line">*.m~</span><br><span class="line"></span><br><span class="line"># Compiled MEX binaries (all platforms)</span><br><span class="line">*.mex*</span><br><span class="line"></span><br><span class="line"># Simulink Code Generation</span><br><span class="line">slprj/</span><br><span class="line"></span><br><span class="line"># Session info</span><br><span class="line">octave-workspace</span><br><span class="line"></span><br><span class="line"># Simulink autosave extension</span><br><span class="line">.autosave</span><br><span class="line"></span><br><span class="line"># Windows txt backup</span><br><span class="line">*.bak</span><br><span class="line"></span><br><span class="line"># sensor data</span><br><span class="line">*.DAT</span><br><span class="line"></span><br><span class="line"># output File</span><br><span class="line">*.mat</span><br><span class="line">*.fig</span><br><span class="line">*.tiff</span><br><span class="line">*.jpg</span><br></pre></td></tr></table></figure>

<h2 id="切换到以前的版本和回到未来的版本"><a href="#切换到以前的版本和回到未来的版本" class="headerlink" title="切换到以前的版本和回到未来的版本"></a>切换到以前的版本和回到未来的版本</h2><p>首先使用<code>git log</code>命令查看提交记录，获取版本 ID：</p>
<p><img src="/images/git%E7%89%88%E6%9C%AC%E5%9B%9E%E9%80%801.png"></p>
<p>然后使用<code>git reset --hard ID</code>回退到指定版本，这里的ID可以只输入前面几位</p>
<p><img src="/images/git%E7%89%88%E6%9C%AC%E5%9B%9E%E9%80%802.png"></p>
<p>如果要回到最新版本，只需<code>git reset --hard ID</code>就可以了，这里的ID是最新版本的ID</p>
<p>如果忘记了最新版本的ID，可以使用<code>git relog</code>来查看</p>
<h2 id="比较分支"><a href="#比较分支" class="headerlink" title="比较分支"></a>比较分支</h2><p>利用Github上的Compare页面，我们可以很方便的比较两个分支的差异，具体做法为：在浏览器地址栏输入：</p>
<p><code>https://github.com/dzxia920/Calf-INS/compare/2489d10..19fed71</code></p>
<p>其格式为：</p>
<p><code>https://github.com/用户名/仓库名/compare/分支1..分支2</code></p>
<p>参考：</p>
<p><a href="https://docs.github.com/zh/pull-requests/committing-changes-to-your-project/viewing-and-comparing-commits/comparing-commits">https://docs.github.com/zh/pull-requests/committing-changes-to-your-project/viewing-and-comparing-commits/comparing-commits</a></p>
<h2 id="常用的Git命令"><a href="#常用的Git命令" class="headerlink" title="常用的Git命令"></a>常用的Git命令</h2><ol>
<li>查看远程库</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git remote [-v | --verbose]</span><br></pre></td></tr></table></figure>

<p><code>git remote</code>会列出每个远程库的简短名字，<code>git remote -v</code>会列出详细信息</p>
<ol start="2">
<li>将本地分支推送到远程主机</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;</span><br></pre></td></tr></table></figure>

<p>例如：<code>$ git push origin master</code>表示，将本地的master分支推送到远程origin主机的master分支，如果远程master分支不存在，则会被新建。</p>
<ol start="3">
<li>分支操作</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git branch</span><br></pre></td></tr></table></figure>

<ul>
<li>查看当前有哪些分支：<code>$ git branch</code></li>
<li>新建一个<code>dev</code>分支：<code>$ git branch dev</code></li>
<li>切换到指定的<code>dev</code>分支：<code>$ git checkout dev </code></li>
<li>查看远程和本地分支：<code>git branch -a</code></li>
<li>删除远程分支<code>dev</code>：<code>git push origin --delete dev</code></li>
<li>修改分支dev的名字：<code>git branch -M dev2 version2 </code></li>
</ul>
<p>…</p>
]]></content>
      <categories>
        <category>工作学习</category>
        <category>编程</category>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>专业问题记录</title>
    <url>/2022/05/16/%E4%B8%93%E4%B8%9A%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<p>本文介绍了本人关于导航专业的一些待解决或已解决问题的记录。</p>
<span id="more"></span>

<h1 id="【TO-FIX】Q1：组合导航中姿态误差的补偿方式"><a href="#【TO-FIX】Q1：组合导航中姿态误差的补偿方式" class="headerlink" title="【TO FIX】Q1：组合导航中姿态误差的补偿方式"></a>【TO FIX】Q1：组合导航中姿态误差的补偿方式</h1><p><img src="/images/%E5%A7%BF%E6%80%81%E8%A1%A5%E5%81%BF%E6%96%B9%E5%BC%8F.png"><br>目前知道的是两种姿态误差扰动的方式是没有区别的，但是补偿时应该用的是上面一种。</p>
]]></content>
      <categories>
        <category>工作学习</category>
        <category>专业</category>
      </categories>
      <tags>
        <tag>Navigation</tag>
      </tags>
  </entry>
  <entry>
    <title>低功耗蓝牙(BLE)安卓开发攻略</title>
    <url>/2022/07/05/%E4%BD%8E%E5%8A%9F%E8%80%97%E8%93%9D%E7%89%99-BLE-%E5%AE%89%E5%8D%93%E5%BC%80%E5%8F%91%E6%94%BB%E7%95%A5/</url>
    <content><![CDATA[<p>本文是Android中关于低功耗蓝牙(BLE)开发的指南。</p>
<span id="more"></span>
<p>在网上找到了一篇写的很好的Android BLE开发攻略，原文地址如下：</p>
<blockquote><footer><strong>Chee Yi Ong, punchthrough</strong><cite><a href="https://punchthrough.com/android-ble-guide/">The Ultimate Guide to Android Bluetooth Low Energy</a></cite></footer></blockquote>
<p>现将其总结如下：</p>
<p>低功耗蓝牙(Bluetooth Lower Energy, BLE)顾名思义，其功耗非常低，同时也具有和其他设备通信的功能，因此在安卓app上受到越来越多人的青睐。在本文中，我们将重温安卓开发者必知的BLE基础概念，同时也将展示一些简单的示例：Android上BLE的扫描、连接、读写、设置指示或通知。大多数代码是用Kotlin写的，但也能很好地转换成Java。示例app完整的实现可见Github开源仓库。</p>
<h1 id="BLE基础"><a href="#BLE基础" class="headerlink" title="BLE基础"></a>BLE基础</h1><h2 id="术语表"><a href="#术语表" class="headerlink" title="术语表"></a>术语表</h2><p>BLE：BLuetooth Low Energy，是2.4G蓝牙无线技术的一个子集，专门为连接的设备提供低功耗且通常不频繁的数据传输。</p>
<p>Central&#x2F;Client：能够扫描和连接BLE外围设备以执行某些操作的设备，在app开发中，一般指的是安卓设备。</p>
<p>Peripheral&#x2F;Server：能够广播BLE信号的设备，通过连接Central以完成某项任务。在app开发中，这通常是正在使用的BLE设备，比如心率监视器。</p>
<p>GATT Service：描述设备特性的一组characteristics（数据字段），例如设备信息的Service可以包含描述设备序列号的characteristic，以及描述设备电池电量的characteristic。</p>
<p>GATT Characteristic：包含有意义数据的实体，通常能够从中读取或写入，例如序列号字符串的characteristic。</p>
<p>GATT Descriptor：一个已定义的属性，描述他所附属的characteristic，例如，the Client Characteristic Configuration descriptor描述了the central当前是否订阅了一个characteristic的值的改变。</p>
<p>Notifications：当外围设备的characteristic值发生改变的时候，外围设备通知Central的一种方法。Central不需要确认它已经收到了数据包。</p>
<p>Indications：和Notification一样，但它的每个数据包都被Central确认。这样保证了他们的交付以吞吐量为代价。</p>
<p>UUID：通用的唯一的标识符，128位数字，用于标识services、characteristics和descriptors。</p>
]]></content>
      <categories>
        <category>工作学习</category>
        <category>编程</category>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Coding</tag>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>基于Hexo的个人博客写作流程</title>
    <url>/2022/04/25/%E5%9F%BA%E4%BA%8EHexo%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%86%99%E4%BD%9C%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<p>本文介绍了配置好Hexo后，博客写作到发布的全流程。包括：如何基于Hexo新建博客，Hexo写作的一些语法、预览和发布到网页。</p>
<span id="more"></span>

<h2 id="新建MarkDown文件"><a href="#新建MarkDown文件" class="headerlink" title="新建MarkDown文件"></a>新建MarkDown文件</h2><p>转至Hexo所在的个人博客文件夹，用cmd打开，输入命令：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">hexo new [layout] &lt;<span class="built_in">title</span>&gt;</span><br></pre></td></tr></table></figure>

<p>例如<code>hexo new post 文章名.md</code>，这样在你的<code>source\_post</code>目录下就会生成<code>文章名.md</code>这样一个MarkDown文件，你就可以在上面修改写文章了。也有人说可以直接把新建的md文件拷贝到<code>source\_post</code>目录下，效果是一样的。</p>
<h3 id="Layout"><a href="#Layout" class="headerlink" title="Layout"></a>Layout</h3><p>Hexo 有三种默认布局，分别是<code>post</code>、<code>page</code> 和 <code>draft</code>。在创建这三种不同类型的文件时，它们将会被保存到不同的路径；而自定义的其他布局和 <code>post</code> 相同，都将储存到 <code>source/_posts</code> 文件夹。</p>
<table>
<thead>
<tr>
<th align="left">布局</th>
<th align="left">路径</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>post</code></td>
<td align="left"><code>source/_posts</code></td>
</tr>
<tr>
<td align="left"><code>page</code></td>
<td align="left"><code>source</code></td>
</tr>
<tr>
<td align="left"><code>draft</code></td>
<td align="left"><code>source/_drafts</code></td>
</tr>
</tbody></table>
<h2 id="写作"><a href="#写作" class="headerlink" title="写作"></a>写作</h2><p>创建好md文件后，就可以开始写作了。</p>
<h3 id="文件头"><a href="#文件头" class="headerlink" title="文件头"></a>文件头</h3><p>利用上述命令创建的md文件会有一个文件头，叫做Front-matter。如下图所示：</p>
<p><img src="/images/hexo-front-matter-demo.png"></p>
<p>Front-matter 是文件最上方以 <code>---</code> 分隔的区域，用于指定个别文件的变量，举例来说：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: Hello World</span><br><span class="line">date: 2013/7/13 20:46:25</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<p>这是<strong>参考示例</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 基于Hexo的个人博客写作流程</span><br><span class="line">date: 2022-04-25 17:16:23</span><br><span class="line">tags: Blog Writing</span><br><span class="line">categories: [教程, 博客写作]</span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">本文介绍了配置好Hexo后，博客写作到发布的全流程。</span><br><span class="line"></span><br><span class="line">&lt;!-- more --&gt;</span><br></pre></td></tr></table></figure>

<p>以下是预先定义的参数，您可在模板中使用这些参数值并加以利用。</p>
<table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">描述</th>
<th align="left">默认值</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>layout</code></td>
<td align="left">布局</td>
<td align="left"><a href="https://hexo.io/zh-cn/docs/configuration#%E6%96%87%E7%AB%A0"><code>config.default_layout</code></a></td>
</tr>
<tr>
<td align="left"><code>title</code></td>
<td align="left">标题</td>
<td align="left">文章的文件名</td>
</tr>
<tr>
<td align="left"><code>date</code></td>
<td align="left">建立日期</td>
<td align="left">文件建立日期</td>
</tr>
<tr>
<td align="left"><code>updated</code></td>
<td align="left">更新日期</td>
<td align="left">文件更新日期</td>
</tr>
<tr>
<td align="left"><code>comments</code></td>
<td align="left">开启文章的评论功能</td>
<td align="left">true</td>
</tr>
<tr>
<td align="left"><code>tags</code></td>
<td align="left">标签（不适用于分页）</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>categories</code></td>
<td align="left">分类（不适用于分页）</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>permalink</code></td>
<td align="left">覆盖文章网址</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>excerpt</code></td>
<td align="left">Page excerpt in plain text. Use <a href="https://hexo.io/docs/tag-plugins#Post-Excerpt">this plugin</a> to format the text</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>disableNunjucks</code></td>
<td align="left">Disable rendering of Nunjucks tag <code>&#123;&#123; &#125;&#125;</code>&#x2F;<code>&#123;% %&#125;</code> and <a href="https://hexo.io/docs/tag-plugins">tag plugins</a> when enabled</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>lang</code></td>
<td align="left">Set the language to override <a href="https://hexo.io/docs/internationalization#Path">auto-detection</a></td>
<td align="left">Inherited from <code>_config.yml</code></td>
</tr>
</tbody></table>
<h3 id="写作的语法"><a href="#写作的语法" class="headerlink" title="写作的语法"></a>写作的语法</h3><p>支持MarkDown最原始的语法，正常写就行了。除此之外，有一些特殊的格式，比如引用。</p>
<h4 id="文章摘要"><a href="#文章摘要" class="headerlink" title="文章摘要"></a>文章摘要</h4><p>在文章中使用 <code>&lt;!-- more --&gt;</code>，那么 <code>&lt;!-- more --&gt;</code> 之前的文字将会被视为摘要。首页中将只出现这部分文字，同时这部分文字也会出现在正文之中。</p>
<p>效果：<br><img src="/images/more%E6%A0%87%E7%AD%BE.png"></p>
<h4 id="插入图片"><a href="#插入图片" class="headerlink" title="插入图片"></a>插入图片</h4><p>把图片放到<code>/source/images</code>文件夹下，然后可以通过<code>![](images/picture.png)</code>来引用图片。</p>
<h4 id="内容标签插件"><a href="#内容标签插件" class="headerlink" title="内容标签插件"></a>内容标签插件</h4><p>Typora里自带的链接引用在Hexo中无法渲染出来，因此需要用Hexo的内容标签插件，其永远是可用的。</p>
<ul>
<li><h5 id="引用块"><a href="#引用块" class="headerlink" title="引用块"></a>引用块</h5></li>
</ul>
<p>总的语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% blockquote [author[, source]] [link] [source_link_title] %&#125;</span><br><span class="line">content</span><br><span class="line">&#123;% endblockquote %&#125;</span><br></pre></td></tr></table></figure>

<h6 id="示例1，引用书中的格言："><a href="#示例1，引用书中的格言：" class="headerlink" title="示例1，引用书中的格言："></a>示例1，引用书中的格言：</h6><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% blockquote 诸葛亮, 诫子书 %&#125;</span><br><span class="line">非淡泊无以明志，非宁静无以致远。</span><br><span class="line">&#123;% endblockquote %&#125;</span><br></pre></td></tr></table></figure>

<p>效果：</p>
<blockquote><p>非淡泊无以明志，非宁静无以致远。</p>
<footer><strong>诸葛亮</strong><cite>诫子书</cite></footer></blockquote>

<h6 id="示例2，引用网上其他文章："><a href="#示例2，引用网上其他文章：" class="headerlink" title="示例2，引用网上其他文章："></a>示例2，引用网上其他文章：</h6><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% blockquote 枫叶, 知乎 https://zhuanlan.zhihu.com/p/102592286 从0开始搭建个人博客 %&#125;</span><br><span class="line">&#123;% endblockquote %&#125;</span><br></pre></td></tr></table></figure>

<p>效果：</p>
<blockquote><footer><strong>枫叶, 知乎</strong><cite><a href="https://zhuanlan.zhihu.com/p/102592286">从0开始搭建个人博客</a></cite></footer></blockquote>

<ul>
<li><h5 id="引用Youtube视频"><a href="#引用Youtube视频" class="headerlink" title="引用Youtube视频"></a>引用Youtube视频</h5></li>
</ul>
<p>语法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% youtube lJIrF4YjHfQ %&#125;</span><br></pre></td></tr></table></figure>

<p>效果：</p>
<div class="video-container"><iframe src="https://www.youtube.com/embed/lJIrF4YjHfQ" frameborder="0" loading="lazy" allowfullscreen></iframe></div>

<h4 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h4><p>代码块可以正常用Markdown的反引号&#96;&#96;&#96;：</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">clear all;</span><br><span class="line">close all;</span><br><span class="line">clc;</span><br></pre></td></tr></table></figure>

<h2 id="预览与发布"><a href="#预览与发布" class="headerlink" title="预览与发布"></a>预览与发布</h2><h3 id="预览"><a href="#预览" class="headerlink" title="预览"></a>预览</h3><p>写好了博客之后，可以先预览一下效果。预览其实就是启动本地服务器看看渲染的效果，命令如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ hexo server </span><br></pre></td></tr></table></figure>

<p>其作用是启动服务器。该命令的简写是<code>$ hexo s</code>。默认情况下，可通过浏览器访问网址 <code>http://localhost:4000/</code>来预览你的博客。可用<code>Ctrl+C</code>停止连接。</p>
<h3 id="发布"><a href="#发布" class="headerlink" title="发布"></a>发布</h3><p>觉得预览没问题了，就可以真正发布到网站上。</p>
<p>发布的流程也很简单，<strong>生成</strong>和<strong>部署</strong>两步即可：</p>
<ol>
<li>生成静态文件：可以简写为：<code>$ hexo g</code>。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>部署到网站上：可以简写为<code>$ hexo d </code>。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<hr>
<p>当然以上两条命令都是可以加参数的。比如：</p>
<p><code>$ hexo d -g</code>：部署之前预先生成静态文件；</p>
<p><code>$ hexo g -d</code>:   生成静态文件后马上部署。</p>
<p>这意味这我们不需要敲两条命令，只需要用上述加参数的命令中的任意一个即可发布出去。</p>
<hr>
<p>另外还有一个<code>clean</code>命令很常用：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ hexo clean</span><br></pre></td></tr></table></figure>

<p>作用是：清除缓存文件 (<code>db.json</code>) 和已生成的静态文件 (<code>public</code>)。在某些情况（尤其是更换主题后），如果发现对站点的更改无论如何也不生效，可能需要运行该命令。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="https://hexo.io/zh-cn/docs/writing.html">Hexo官方文档</a></li>
<li><a href="https://zenreal.github.io/posts/51388/">https://zenreal.github.io/posts/51388/</a></li>
</ol>
]]></content>
      <categories>
        <category>工作学习</category>
        <category>博客写作</category>
      </categories>
      <tags>
        <tag>Blog Writing</tag>
      </tags>
  </entry>
  <entry>
    <title>MATLAB批量复制或移动文件</title>
    <url>/2023/09/13/MATLAB%E6%89%B9%E9%87%8F%E5%A4%8D%E5%88%B6%E6%88%96%E7%A7%BB%E5%8A%A8%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<p>本文介绍了在MATLAB中利用<code>movefile</code>或<code>copyfile</code>结合<code>fullfile</code>，<strong>使用通配符</strong>批量移动或拷贝文件的操作</p>
<span id="more"></span>

<p>假设文件目录结构如下：</p>
<p>在<code>E:\data\2023-08-09-直线100m航向对齐数据\04_res\</code>有8个case，以第一个case为例，下有子文件夹：</p>
<ul>
<li><p><code>E:\data\2023-08-09-直线100m航向对齐数据\04_res\case1\first_pva\</code></p>
</li>
<li><p><code>E:\data\2023-08-09-直线100m航向对齐数据\04_res\case1\second_pva\</code></p>
</li>
</ul>
<p>现需要将<code>first_pva</code>文件夹下的<code>INS_imuLeftFoot.txt</code>和<code>INS_imuRightFoot.txt</code>移动到<code>second_pva</code>文件夹下，可使用下面的命令：</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> icase = <span class="number">1</span>:<span class="number">8</span></span><br><span class="line">	caseFolder = [<span class="string">&#x27;E:\data\2023-08-09-直线100m航向对齐数据\04_res&#x27;</span>, <span class="string">&#x27;case&#x27;</span>, num2str(icase)];</span><br><span class="line">	copyfile(fullfile(caseFolder, <span class="string">&#x27;first_pva&#x27;</span>,<span class="string">&#x27;INS_imu*Foot.txt&#x27;</span>), fullfile(caseFolder, <span class="string">&#x27;second_pva&#x27;</span>));</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>工作学习</category>
        <category>编程</category>
        <category>MATLAB</category>
      </categories>
  </entry>
  <entry>
    <title>使用JLINK烧录模块流程</title>
    <url>/2023/11/04/%E4%BD%BF%E7%94%A8JLINK%E7%83%A7%E5%BD%95%E6%A8%A1%E5%9D%97%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<p>本文介绍了使用JLINK配合Keil烧录硬件模块的流程</p>
<span id="more"></span>
<h1 id="使用JLINK烧录模块流程"><a href="#使用JLINK烧录模块流程" class="headerlink" title="使用JLINK烧录模块流程"></a>使用JLINK烧录模块流程</h1><ol>
<li>将JLINK连接模块，注意口的方向。<strong>将模块开机</strong>；</li>
<li>打开Keil，点击<code>Options for Target</code>，使用JLINK，配置如下：</li>
</ol>
<p><img src="/images/JLINK%E7%83%A7%E5%BD%951.png"></p>
<ol start="3">
<li>点击<code>Settings</code>，观察是否连接成功，连接成功后右侧<code>SW Device</code>会有显示：</li>
</ol>
<p><img src="/images/JLINK%E7%83%A7%E5%BD%952.png"></p>
<ol start="4">
<li>先<code>Rebuild</code>生成，然后<code>Load</code>将代码烧入模块内。<code>Load</code>时下方状态栏会有进度条：</li>
</ol>
<p><img src="/images/JLINK%E7%83%A7%E5%BD%953.png"></p>
<p><img src="/images/JLINK%E7%83%A7%E5%BD%954.png"></p>
<p>整体界面如下：</p>
<p><img src="/images/JLINK%E7%83%A7%E5%BD%955.png"></p>
]]></content>
      <categories>
        <category>工作学习</category>
        <category>专业</category>
      </categories>
  </entry>
  <entry>
    <title>平面轨迹对齐推导及代码</title>
    <url>/2023/10/24/%E5%B9%B3%E9%9D%A2%E8%BD%A8%E8%BF%B9%E5%AF%B9%E9%BD%90%E6%8E%A8%E5%AF%BC%E5%8F%8A%E4%BB%A3%E7%A0%81/</url>
    <content><![CDATA[<p>这篇文章介绍了平面轨迹对齐的原理和推导，并附上代码。</p>
<span id="more"></span>

<p>问题引入<br>在评估惯导推算轨迹精度时，需要将惯导轨迹与参考轨迹对齐。<br>$$<br>\begin{split}<br>\begin{bmatrix}  x_{ref} \ y_{ref} \end{bmatrix} &#x3D; &amp;<br>\begin{bmatrix}  l\cdot sin(\psi_{ref}) \ l \cdot cos(\psi_{ref}) \end{bmatrix} &#x3D;<br>\begin{bmatrix}  l\cdot sin(\psi_1 - \Delta \psi) \ l \cdot cos(\psi_1 - \Delta \psi) \end{bmatrix} &#x3D;<br>\begin{bmatrix}  l\cdot(sin\psi_1cos\Delta\psi - cos\psi_1 sin\Delta\psi) \ l\cdot(cos\psi_1cos\Delta\psi + sin\psi_1 sin\Delta\psi) \end{bmatrix}  \ &#x3D; &amp;<br>\begin{bmatrix}  x_1 \cdot cos\Delta\psi - y_1 \cdot sin\Delta\psi \ x_1 \cdot sin\Delta\psi - y_1 \cdot cos\Delta\psi \end{bmatrix} &#x3D;<br>\begin{bmatrix}  cos\Delta\psi &amp; -sin\Delta\psi \ sin\Delta\psi &amp; cos\Delta\psi \end{bmatrix} \begin{bmatrix}  x_1 \ y_1 \end{bmatrix}<br>\end{split}<br>$$</p>
]]></content>
      <categories>
        <category>工作学习</category>
        <category>专业</category>
      </categories>
  </entry>
</search>
